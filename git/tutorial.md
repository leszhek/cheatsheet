## Git - простая инструкция
[Вернуться](./)

### Базовые команды
- git init - создает репо
- git status - показывает статус измененных файлов
- git add . - добавляет все файлы в индекс коммита (можно перечислить файлы вместо точки)
- git commit - собственно, делает коммит
	- git commit -m "Название коммта" - задает название коммита (-m - message)
	- git commit -a -m "Название коммита" - добавляет в коммит все изменения, без необходимости *git add*
- git log - просмотр всех коммитов

### Частичный коммит
- git add -p - позволяет внести не все правки, а определенные. Опции:
	- y - принять все
	- n - не принимать все
	- q - выйти из действия
	- a - принять этот и все последующие
	- d - не принимать этот и последующие
	- s - разделить текущий фрагмент на более мелкие фрагменты
	- e - вручную отредактировать кусок
	- ? - помощь

### Удалить/переименовать
- git rm --cached \<filename> - удалить из отслеживания (без --cached - удалить файл)
- git mv \<filename> - переименовать файл
	
### Сравнение версий
- git show - просмотреть один последний коммит (в отличии от *log* - здесь показаны изменения, которые были сделаны)
- git diff \<первый хэш> \<второй хэш> - посмотреть разницу между версиями 
- git diff HEAD~1 - изменения внесенные коммитом, относительно предыдущего (номер после тильды - номер коммита, который мы хотим посмотреть, последний коммит имеет номер 1)
- git diff HEAD1 HEAD2 - сравнить коммиты
- git diff \<filename> - неиндексированные изменения
- git diff --name-only \<хэш> - список измененных файлов

### Отмена изменений и откат версий
- git checkout -- \<filename> - отменить изменения файла не внесенные в индекс
- git reset HEAD \<filename> - отменить индексацию файла
- git commit --amend - добавляет изменения в последний коммит (но сначала эти изменения нужно добавить в индекс)
- git revert \<hash> - откатывает коммит

### Сброс истории коммитов
- git reset --hard \<hash> - отменить все изменения после обозначенного коммита. Если хэш не указывать - история будет сброшена до головы (последнего коммита)
- git reset --soft \<hash> - срезать все коммиты после обозначенного, а все изменения отправить в индекс (по сути - удалить историю частичных коммитов, чтобы сделать один - объединяющий)
- git reset --mixed \<filename> - то же, что git reset HEAD \<filename> (по умолчанию reset работает в режиме --mixed). А вообще этот режим работает так - все коммиты срезаются, а изменения попадают в *unstaged*
	

### Формирование понятной истории ветки
Зачастую, во время работы, по крайней мере у меня, получается много коммитов. Чтобы на код-ревью это не стало проблемой, а история читалась понятно - необходимо привести коммиты к логической последовательности (убрать лишние, поменять описание и т.д.)
- git rebase -i HEAD~6 (перебазироваться на 6 коммит ниже головы и включить интерактивный режим). <br>
В этом режиме можно указать, что делать с коммитами. Основное:
- pick - оставить коммит
- squash - слить со следующим (который pick)
- delete - удалить

Если просто удалить коммит из списка - 

### Репозитории и коллективная работа
Получение собственной копии из центрального репозитория называется **клонирование** и выполняется с помощью команды **clone**. А чтобы отправить изменения обратно на сервер, нужно выпонить команду **push**. Если с репозиторием работают несколько человек, то перед отправкой необходимо выполнить команду **pull** (чтобы получить к себе на комп все изменения, которые произошли за это время)
- git clone \<ссылка на репо>
	(выглядит так *git clone git@github.com:leszhek/leszhek.git*)
	